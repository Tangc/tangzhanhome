# 大家好，我是唐斩，这是第103天第120篇分享。

## AI编程本质思考
看到一个内容讲 AI 编程的复杂度阈值，结合我的实践，我的思考
- AI编程的实际受众是两类，一类是懂软件工程的，一类是不懂软件工程的。
- 懂软件工程的，以原本的软件研发工作者为主，本职工作就是做软件，对AI编程的期望是提升自己的效率，或者替代部分自己的工作。但重点在于，软件开发越资深，编码的工作就越少，工程的工作就越多。编码的工作不止变少，还变的更深更定制更新(更深意味着AI探索深度更大被提示词激活那个区域更难，更定制意味着"反模式"，更新意味着模型语料里没有)，举几个例子，例子1大厂内部的技术框架是没有对外资料的，除了大厂内部训练的模型，外部模型无从理解框架原理和用法，例子2 kapathy大神写 nanochat 的时候没法用AI编程替代，必须自己写。工程的部分，不是编码，是领域性的结构知识输出，最终体现为文档，但做过架构的都知道，如果只看架构师的文档去落地系统，大概率要出问题，必须架构师亲自在场，才能在研发期间补齐那些知识。举个段子，为什么美国现在没法重现登月，因为虽然设计资料在，但是当年的老工程师们不在了，复现不出来那些工艺结果，和不知道有些实际制作时的调整原因和方法。
对软件开发者的启示？把工作中，适合当下AI编程的部分分离出来，交给AI实现。不适合的，要等待一个软件工程Agent了，现阶段的工具还集中在编码层面。
- 不懂软件工程的，以接近研发的相关人员为主，如产品、运营、AI爱好者等。对AI编程的期望是以极少的自然语言驱动完成符合自己要求的软件产品，一般是网页工具或者APP工具，复杂的话是网页产品或者APP产品。现阶段，非结构化方法的AI编程能cover的复杂度估计是万行有效代码内(我觉得2-3是最舒服的)，这个范围内，一般的工具是足足够够的了。产品级别就要万行规模了，就要有AI编程方法了。AI编程方法是AI原生的，借鉴的软件工程的驱动方式，例如著名的 spec 驱动法。
我之前一直疑惑，信息量不会凭空产生，通过spec驱动增加出来那么多文字的信息量是怎么来的？现在逐渐理解了，是从大模型的知识里来的，也就是和上述架构师相反的 更浅更通用更模式化 的代码和产品经验。
对AI编程开发者的启示？AI原生思维，不要去追求理解软件工程，代码细节。以完成工具或产品为目标。要学习的是AI编程法(我最近做短视频的内容范围就在这里)