分享 D34E45
1、VibeCoding 与 软件工程
听 VSCode 开发者的分享有一条观点“VibeCoding应该是不看代码的，否则就进入软件工程了，一点都不 Vibe”。
基于此最简单的实践就是工作代码我古法软件工程，副业项目我VibeCoding只追求结果。
但实际来说，就像架构一样，是需要balance的。

局部的(限定上下文)，清晰的(经典套路，比如设计模式、流行框架等)，整体性的(新建)。VibeCoding it。
全局的(上下文超长)，不清晰的(性能优化，稳定性等)，穿插性的(雕花)。 软件工程 it。

这叫什么， Maybe Call It “Hybrid Vibe Coding” ？

2、我的 Java VibeCoding 工作流
- 新建一个文件夹，拉取同一个项目(git clone xxx)
- 修改项目下的提交者名字，加上ai标识 (git user.name ai.xxx)
- 基于开发分支，新建一个ai开发分支(git checkout -b ai/xxx --track upstream/feature/xxx)
- 打开你喜欢的 Agent，enjoy Vibe Coding，提交并push到仓库(git commit && git push)
- 分情况 
 - 低风险 || 代码量小的，merge 到 feature 分支，进行后续测试
 - 高风险 || 代码量大的，pr 到 feature 分支，仔细 Review 并测试


3、VibeCoding的两种流派
流派1，无尽对话，直到正确
一直和Agent对话，直到程序达到预期目标。
优点：纯粹，人可以不深入代码细节。
缺点：费人费钱。很磨人(对话到后期非常容易按下葫芦起了瓢)，token用量大
适用：
 - 不熟悉的技术栈。
 - 不了解技术细节时。

流派2，对话一轮，然后手动
Agent只负责代码从0到1的生成，后续的调整都通过人来手动完成。
优点：可控性强，充分发挥人的技术能力。
缺点：最终Agent代码量占比低，没有充分发挥Agent的威力。
适用：
 - 交付紧张，人力充裕，延期敏感时
 - 需要充分掌控代码细节的项目

4、Spec迭代的问题
今天遇到一个问题，写 Spec 的时候忘记写 lombok 了，结果生成了一堆 getset 方法。
如果改 Spec ，再重新生成，有点浪费 Token。
如果改 Spec ，要求用上 lombok 的话，几乎也是全类扫描和删除大量代码，耗费不少 Token。
如果改 Spec ，我自己调整的话，省了 Token，但是要花自己的时间。

现在 Agent 工作的时候，我都是把存起来的技术文章打开一篇阅读，等它干完活。

所以正确的做法是：Agent可以干的活，就让它干。低难度的task，可以切换成免费或者低费用的模型或Agent来完成。
// Cursor 的 gpt5 免费一周，可以试试。